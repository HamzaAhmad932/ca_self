<?php


namespace App\Jobs\SyncBooking;


use App\Events\BAPropertyChangeEncounteredEvent;
use App\PropertyInfo;
use App\System\PMS\Models\Booking;
use App\System\PMS\PMS;
use App\UserAccount;
use Exception;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Carbon;


class BASyncBookingJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels, SyncBookingTrait;


    public $tries = 1;

    /**
     * @var bool
     */
    private $maintenance_mode = false;
    /**
     * @var UserAccount
     */
    private $user_account;
    /**
     * @var PropertyInfo
     */
    private $property_info;

    /**
     * BASyncBookingJob constructor.
     * Specific Property for whom job dispatched to sync Bookings.
     * If Maintenance mode True then no email to guest will be sent for Card missing.
     * modified request will auto generated by CA to get Token then verify guest card and email to guest if required.
     * BASyncBookingJob constructor.
     * @param UserAccount $user_account
     * @param PropertyInfo $property_info
     * @param bool $maintenance_mode
     */
    public function __construct(UserAccount $user_account, PropertyInfo $property_info, bool $maintenance_mode = false) {

        self::onQueue('ba_syc_bookings');

        $this->user_account = $user_account;
        $this->property_info = $property_info;
        $this->maintenance_mode = $maintenance_mode;

        /*Log::info(__FILE__,
            [
                __CLASS__ => 'dispatch',
                'user_account_id' => $this->user_account->id,
                'property_info' => $this->property_info->id,
            ]
        );*/

    }

    /**
     * Execute the job.
     * @throws Exception
     */
    public function handle() {
        try {

            $this->init_booking_job_helper();

            // Sync New Bookings
            $this->handleSyncBookingJob();

        } catch (Exception $e) {

            log_exception_by_exception_object($e);
        }
    }



    private function handleSyncBookingJob() {
        /**
         * @var Booking $pms_booking
         */

        $pms = new  PMS($this->user_account);
        $pms_bookings = $this->fetch_Booking_Details_json_xml($this->property_info, $pms);

        $sync_from = !empty($this->property_info->sync_booking_from) ? $this->property_info->sync_booking_from
            : Carbon::now()->subHour(24)->toDateTimeString();

        foreach ($pms_bookings as $pms_booking) {

            try {

                if ($pms_booking->propertyId != $this->property_info->pms_property_id) {

                    //check if booking property changed -- If changed then update new property inside event
                    //this event will return true/false -- but here we don't need to check
                    event(new BAPropertyChangeEncounteredEvent($pms_booking->id));

                    continue;
                }

                if (! $this->isBookingValidToSync($this->user_account, $pms_booking, $sync_from)) {
                    continue;
                }

                if (!$this->shouldProcessIfGroupBooking($pms_booking->masterId, $this->user_account->id)) {

                    $this->insertBookingOnHold($this->user_account->id, $pms_booking->id, $pms_booking->masterId,
                        'new', $pms_booking->channelCode, $this->property_info->pms_property_id,
                        null, null, __CLASS__
                    );

                } else {
                    $this->createBooking($pms, $pms_booking);
                }

            } catch (Exception $exception) {
                log_exception_by_exception_object($exception,
                    json_encode([
                        'user_account_id' => $this->user_account->id,
                        'property_info_id' => $this->property_info->id,
                        'File' => __FILE__

                    ])
                );
            }
        }

        $this->updateSyncFrom($this->property_info);
    }


    /**
     * @param PMS $pms
     * @param Booking $pms_booking
     * @throws Exception
     */
    private function createBooking(PMS $pms, Booking $pms_booking) {

        $booking_source_form_id = $this->bookingSourceFormId($this->user_account, $pms_booking->channelCode);

        // Fetch card from PMS or from booking object
        $card = $this->getCard($this->user_account, $this->property_info, $pms, null, $pms_booking->cardCvv, $pms_booking);
        $card->adjust_first_last_name_if_empty_any();

        $typeOfPaymentCard = $this->getTypeOfPaymentCard($pms_booking, $this->user_account);


        // Create BookingInfo record
        $booking_info = $this->insertBookingInfoRecord($this->user_account, $this->property_info, $pms_booking,
            $typeOfPaymentCard, $booking_source_form_id, true
        );


        /*If Maintenance Mode Active Set $booking_info->maintenance to avoid sending card missing emails
         and get_card on modify Ping. */
        $booking_info->maintenance = $this->maintenance_mode;


        //TRANSACTION_INITS | CC AUTH | SD AUTH RECORDS
        $this->insertTransactionRecords($this->user_account, $this->property_info, $pms_booking, $booking_info,
            $card, $booking_source_form_id, $typeOfPaymentCard
        );
    }
}